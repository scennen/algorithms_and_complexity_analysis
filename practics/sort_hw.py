import time
import random
import matplotlib.pyplot as plt


def bubble_sort(arr):
    """
    Сортирует массив методом "пузырька".
    Идея: многократно проходим по массиву, сравнивая соседние элементы.
    Если левый > правого — меняем их местами. За каждый проход самый большой элемент "всплывает" в конец.
    Оптимизация: если за проход не было обменов — массив уже отсортирован, выходим.
    """

    n = len(arr)  # Запоминаем длину массива — она нам понадобится несколько раз

    # Внешний цикл: количество проходов. Нам нужно максимум n-1 проходов,
    # потому что после каждого прохода один элемент гарантированно становится на своё место (в конце)
    for i in range(n):

        swapped = False  # Флаг: был ли хоть один обмен на этом проходе?

        # Внутренний цикл: проходим от начала до "неотсортированного конца"
        # После i-го прохода последние i элементов уже отсортированы — их трогать не нужно
        for j in range(0, n - i - 1):

            # Сравниваем текущий элемент с его правым соседом
            if arr[j] > arr[j + 1]:
                # Если левый больше правого — меняем их местами (элемент "всплывает")
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
                swapped = True  # Зафиксировали, что был обмен

        # Если на этом проходе не было ни одного обмена — массив уже отсортирован!
        if not swapped:
            break  # Досрочно выходим из внешнего цикла — экономим время


def selection_sort(arr):
    """
    Сортирует массив методом выбора.
    Идея: на каждом шаге находим минимальный элемент в оставшейся части массива
    и меняем его местами с первым элементом неотсортированной части.
    Таким образом, слева постепенно строится отсортированная часть.
    """

    n = len(arr)  # Запоминаем длину массива

    # Проходим по всем позициям массива, кроме последней (она сама встанет на место)
    for i in range(n):

        # Предполагаем, что текущий элемент (на позиции i) — минимальный
        min_idx = i

        # Ищем реальный минимальный элемент в оставшейся части массива (от i+1 до конца)
        for j in range(i + 1, n):
            if arr[j] < arr[min_idx]:  # Если нашли элемент меньше текущего минимума
                min_idx = j  # Обновляем индекс минимального элемента

        # Меняем местами найденный минимальный элемент с первым элементом неотсортированной части
        # (то есть с элементом на позиции i)
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
        # Примечание: даже если min_idx == i (минимум уже на месте), обмен всё равно произойдёт — это нормально


def insertion_sort(arr):
    """
    Сортирует массив методом вставок.
    Идея: представьте, что вы собираете карты в руке. Берёте по одной карте и вставляете её на правильное место
    среди уже отсортированных карт слева.
    На каждом шаге берем элемент и "проталкиваем" его влево, пока он не окажется перед бо́льшим элементом.
    """

    # Начинаем со второго элемента (индекс 1), потому что первый элемент считается "уже отсортированным"
    for i in range(1, len(arr)):

        key = arr[i]  # Текущий элемент, который мы хотим вставить в отсортированную часть
        j = i - 1  # Индекс последнего элемента в отсортированной части (слева от key)

        # Пока не вышли за границу массива и элемент слева больше ключа — двигаем элементы вправо
        while j >= 0 and key < arr[j]:
            arr[j + 1] = arr[j]  # Сдвигаем больший элемент на одну позицию вправо
            j -= 1  # Переходим к следующему элементу слева

        # Вставляем ключ на найденное место (j+1, потому что j уменьшился на 1 лишний раз в цикле)
        arr[j + 1] = key


def time_sorting_algorithms(sizes):
    """
    Замеряет время выполнения трёх сортировок на массивах разного размера.
    Возвращает словарь с результатами.
    """
    results = {
        "Bubble Sort": [],
        "Selection Sort": [],
        "Insertion Sort": []
    }

    for n in sizes:
        print(f"\nТестируем массив размера {n}...")

        # Генерируем случайный массив
        arr = [random.randint(1, 1000) for _ in range(n)]

        # Bubble Sort
        arr_copy = arr.copy()
        start = time.perf_counter()
        bubble_sort(arr_copy)
        end = time.perf_counter()
        results["Bubble Sort"].append(end - start)
        print(f"  Bubble Sort: {end - start:.5f} сек")

        # Selection Sort
        arr_copy = arr.copy()
        start = time.perf_counter()
        selection_sort(arr_copy)
        end = time.perf_counter()
        results["Selection Sort"].append(end - start)
        print(f"  Selection Sort: {end - start:.5f} сек")

        # Insertion Sort
        arr_copy = arr.copy()
        start = time.perf_counter()
        insertion_sort(arr_copy)
        end = time.perf_counter()
        results["Insertion Sort"].append(end - start)
        print(f"  Insertion Sort: {end - start:.5f} сек")

    return results


sizes = [100, 500, 1000, 2000]  # Можно добавить 3000, но Bubble будет очень медленной!
results = time_sorting_algorithms(sizes)


def plot_sorting_results(sizes, results):
    plt.figure(figsize=(12, 6))

    for algo_name, times in results.items():
        plt.plot(sizes, times, marker='o', label=algo_name, linewidth=2)

    plt.title("Сравнение времени выполнения простых сортировок", fontsize=16)
    plt.xlabel("Размер массива (n)", fontsize=14)
    plt.ylabel("Время выполнения (секунды)", fontsize=14)
    plt.legend(fontsize=12)
    plt.grid(True, linestyle='--', alpha=0.7)
    plt.xticks(sizes)
    plt.tight_layout()
    plt.show()


# Запускаем построение графика
plot_sorting_results(sizes, results)